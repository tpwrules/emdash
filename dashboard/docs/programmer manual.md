## Introduction

Welcome to the programmer's manual for the Einstein Motorsport Dashboard. This document explains how the firmware works and the functions available to customizers.

The firmware is divided into four distinct sections:
* Application and Main Loop
* Canvar System and Variable Handlers
* Screen
* Platform

## Application and Main Loop

The application receives the timer interrupt and contains the main loop. The main loop calls the variable handlers when there are new values.

The application is responsible for dash mode changes. It clears the screen in preparation for a mode change and calls the appropriate functions to coordinate the change. The variable `app_mode_change_func` should point to the mode change function. More details are in the customizer manual.

The application code is contained in `src/app.c`. This file also has helper routines which may be useful across the application.

### Application Operations

The following operations change the state of the application:
* `void app_show_next_mode(void)` shows the next dash mode by clearing the mode area of the screen, then calling the function pointed to by `app_mode_change_func` with a `false` value.

The following helper routines are available:
* `uint32_t hysteresis(uint32_t old, uint32_t new, uint32_t max_delta)` applies hysteresis to a value. If the difference between `new` and `old` is greater than `max_delta`, the function returns `new`. Otherwise, it returns `old`.

## Canvar System and Variable Handlers

The canvar (CAN variable) system is responsible for parsing incoming CAN messages and storing new variable values in memory. The main loop then calls a function for each variable that acts on its new value.

Canvars are defined in the canvar database. Defining a new canvar is covered in the customizer manual.

The canvar processor is contained in `src/canvar.c`. The canvar database is automatically generated by `can/canvars.py`. The generated canvar database is contained in `src_gen/canvar_defs.c` and `src_gen/canvar_defs.h`.

### Canvar Operations

NOTE: All canvar operations must be done with interrupts disabled!

If a canvar has a specific `<name>`, then `cv_<name>` is the data structure which holds its value (a `canvar_state_t`) and `CV_ID_<name in uppercase>` is defined as its ID in the data structure array.

The following operations on canvars are supported:
* `CV_RENEW(cv_<name>)` re-sets a variable to new as long as as it is a valid value.
* `CV_CALL_NEXT_UPDATE(cv_<name>)` re-sets a variable to invalid as long as it is not a new value. This has the effect that the next update to that variable, even if it is the same value, will call the callback.

## Screen

The dashboard is displayed on a 240x64 graphic LCD using the RA6963 controller. Please consult `src/screen.h` for documentation on the screen functions.

## Platform

The platform interfaces between the application and hardware. If you would like to call the platform interrupt functions from within the application, interrupts must be turned off!

The platform code for the simulator is contained in `pc/platform_pc.h` and in the simulator itself. The platform code for the real device is contained in `src_11c24/`

The plaform calls the following interrupt functions in the application to perform work:
* `void app_can_interrupt(uint32_t msg_id, uint8_t dlc, const uint8_t *data)` is called to process a new CAN message.
* `void app_canvar_interrupt(uint8_t cv_id, uint32_t val)` is called to set a specific canvar.
* `void app_timer_interrupt(void)` is called every 10 milliseconds to advince time.

### Platform Operations

The following operations affect the platform:
* `void interrupt_disable(void)` disables interrupts. The above interrupt functions will no longer be called.
* `void interrupt_enable(void)` enables interrupts. The above interrupt functions will be called again.
* `void interrupt_wait(void)` waits for an interrupt to occur, then returns with interrupts enabled. It must be called with interrupts disabled to avoid possibly deadlocking.